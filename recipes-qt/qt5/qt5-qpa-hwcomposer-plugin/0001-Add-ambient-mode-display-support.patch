From 7706c4722a851d4e5a7d807e3743443eeb425747 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Darrel=20Gri=C3=ABt?= <dgriet@gmail.com>
Date: Mon, 5 Sep 2022 22:35:07 +0200
Subject: [PATCH] Add ambient mode display support
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Add ability to keep the screen on while in deep sleep mode.
This is achieved by setting the power mode to HWC_POWER_MODE_DOZE_SUSPEND.
We need PowerHAL to setInteractive based on display state, this is required for some platforms to make ambient mode work.

If the display fails to be validated the `QPA_HWC2_FORCE_DOZE_UPDATE` environment variable can be used to temporarily switch the display to on mode.

Signed-off-by: Darrel GriÃ«t <dgriet@gmail.com>
---
 hwcomposer/hwcomposer_backend.cpp     | 46 +++++++++++++++++++++------
 hwcomposer/hwcomposer_backend.h       |  7 +++-
 hwcomposer/hwcomposer_backend_v0.cpp  |  4 +--
 hwcomposer/hwcomposer_backend_v0.h    |  2 +-
 hwcomposer/hwcomposer_backend_v10.cpp | 12 +++++--
 hwcomposer/hwcomposer_backend_v10.h   |  2 +-
 hwcomposer/hwcomposer_backend_v11.cpp | 27 +++++++++++++---
 hwcomposer/hwcomposer_backend_v11.h   |  6 +++-
 hwcomposer/hwcomposer_backend_v20.cpp | 39 +++++++++++++++++++----
 hwcomposer/hwcomposer_backend_v20.h   | 11 ++++++-
 hwcomposer/hwcomposer_context.cpp     | 18 ++++++++++-
 hwcomposer/hwcomposer_context.h       |  4 +++
 hwcomposer/qeglfsintegration.cpp      |  6 ++++
 13 files changed, 153 insertions(+), 31 deletions(-)

diff --git a/hwcomposer/hwcomposer_backend.cpp b/hwcomposer/hwcomposer_backend.cpp
index c8bf865..a358e11 100644
--- a/hwcomposer/hwcomposer_backend.cpp
+++ b/hwcomposer/hwcomposer_backend.cpp
@@ -56,8 +56,8 @@ extern "C" void *android_dlopen(const char *filename, int flags);
 extern "C" void *android_dlsym(void *handle, const char *symbol);
 extern "C" int android_dlclose(void *handle);
 
-HwComposerBackend::HwComposerBackend(hw_module_t *hwc_module, void *libmsf)
-    : hwc_module(hwc_module), libminisf(libmsf)
+HwComposerBackend::HwComposerBackend(hw_module_t *hwc_module, power_module_t *pwr_module, void *libmsf)
+    : hwc_module(hwc_module), pwr_module(pwr_module), libminisf(libmsf)
 {
 }
 
@@ -75,6 +75,7 @@ HwComposerBackend::create()
 {
     hw_module_t *hwc_module = NULL;
     hw_device_t *hwc_device = NULL;
+    power_module_t *pwr_module = NULL;
     void *libminisf;
     void (*startMiniSurfaceFlinger)(void) = NULL;
 
@@ -103,12 +104,31 @@ HwComposerBackend::create()
         fprintf(stderr, "libminisf is incompatible or missing. Can not possibly start the SurfaceFlinger service. If you're experiencing troubles with media try updating droidmedia (and/or this plugin).");
     }
 
+    // Open power module for setting interactive state based on screen on/off.
+    if (!hw_get_module(POWER_HARDWARE_MODULE_ID, (const hw_module_t **)(&pwr_module))) {
+        pwr_module->init(pwr_module);
+        fprintf(stderr, "== power module ==\n");
+        fprintf(stderr, " * Address: %p\n", pwr_module);
+        fprintf(stderr, " * Module API Version: %x\n", pwr_module->common.module_api_version);
+        fprintf(stderr, " * HAL API Version: %x\n", pwr_module->common.hal_api_version); /* should be zero */
+        fprintf(stderr, " * Identifier: %s\n", pwr_module->common.id);
+        fprintf(stderr, " * Name: %s\n", pwr_module->common.name);
+        fprintf(stderr, " * Author: %s\n", pwr_module->common.author);
+        fprintf(stderr, "== power module ==\n");
+        // Some platforms require explicitly setting a powerhint in order for the PowerHAL to load.
+        // This rule indicates that the user is interacting with the device.
+        // Use NULL to indicate an unknown estimate length of interaction.
+        pwr_module->powerHint(pwr_module, POWER_HINT_INTERACTION, NULL);
+    } else {
+        fprintf(stderr, "PowerHAL is missing or not working, display doze mode may not work\n");
+    }
+
 #ifdef HWC_PLUGIN_HAVE_HWCOMPOSER2_API
     if (!qEnvironmentVariableIsEmpty("QT_QPA_FORCE_HWC2")) {
         // Create hwcomposer backend directly without opening hardware module
         // because on some devices loading hwc2 module twice breaks graphics
         // (The first load is in the composer android service.)
-        return new HwComposerBackend_v20(NULL, libminisf);
+        return new HwComposerBackend_v20(NULL, pwr_module, libminisf);
     }
 #endif
 
@@ -140,7 +160,7 @@ HwComposerBackend::create()
         if ((hwc_device->version == HWC_DEVICE_API_VERSION_0_1) ||
             (hwc_device->version == HWC_DEVICE_API_VERSION_0_2) ||
             (hwc_device->version == HWC_DEVICE_API_VERSION_0_3)) {
-            return new HwComposerBackend_v0(hwc_module, hwc_device, libminisf);
+            return new HwComposerBackend_v0(hwc_module, hwc_device, pwr_module, libminisf);
         }
 #endif
 
@@ -150,11 +170,11 @@ HwComposerBackend::create()
             case HWC_DEVICE_API_VERSION_0_1:
             case HWC_DEVICE_API_VERSION_0_2:
             case HWC_DEVICE_API_VERSION_0_3:
-                return new HwComposerBackend_v0(hwc_module, hwc_device, libminisf);
+                return new HwComposerBackend_v0(hwc_module, hwc_device, pwr_module, libminisf);
 #endif
 #ifdef HWC_DEVICE_API_VERSION_1_0
             case HWC_DEVICE_API_VERSION_1_0:
-                return new HwComposerBackend_v10(hwc_module, hwc_device, libminisf);
+                return new HwComposerBackend_v10(hwc_module, hwc_device, pwr_module, libminisf);
 #endif /* HWC_DEVICE_API_VERSION_1_0 */
 #ifdef HWC_PLUGIN_HAVE_HWCOMPOSER1_API
             case HWC_DEVICE_API_VERSION_1_1:
@@ -172,11 +192,11 @@ HwComposerBackend::create()
 #endif
                 // HWC_NUM_DISPLAY_TYPES is the actual size of the array, otherwise
                 // underrun/overruns happen
-                return new HwComposerBackend_v11(hwc_module, hwc_device, libminisf, HWC_NUM_DISPLAY_TYPES);
+                return new HwComposerBackend_v11(hwc_module, hwc_device, pwr_module, libminisf, HWC_NUM_DISPLAY_TYPES);
 #endif /* HWC_PLUGIN_HAVE_HWCOMPOSER1_API */
 #ifdef HWC_PLUGIN_HAVE_HWCOMPOSER2_API
             case HWC_DEVICE_API_VERSION_2_0:
-                return new HwComposerBackend_v20(NULL, libminisf);
+                return new HwComposerBackend_v20(NULL, pwr_module, libminisf);
 #endif
             default:
                 fprintf(stderr, "Unknown hwcomposer API: 0x%x/0x%x/0x%x\n",
@@ -189,14 +209,22 @@ HwComposerBackend::create()
 #ifdef HWC_PLUGIN_HAVE_HWCOMPOSER2_API
     else {
         // Create hwc2 backend directly if opening hardware module fails
-        return new HwComposerBackend_v20(NULL, libminisf);
+        return new HwComposerBackend_v20(NULL, pwr_module, libminisf);
     }
 #endif
 
     fprintf(stderr, "Unable to load hwcomposer module\n");
     return NULL;
 }
+void
+HwComposerBackend::ambientModeEnabled(bool enable)
+{
+    if (!ambientModeSupport()) {
+        return;
+    }
 
+    m_ambientMode = enable;
+}
 void
 HwComposerBackend::destroy(HwComposerBackend *backend)
 {
diff --git a/hwcomposer/hwcomposer_backend.h b/hwcomposer/hwcomposer_backend.h
index d318124..d308121 100644
--- a/hwcomposer/hwcomposer_backend.h
+++ b/hwcomposer/hwcomposer_backend.h
@@ -51,6 +51,7 @@
 
 #include <hardware/hardware.h>
 #include <hardware/hwcomposer.h>
+#include <hardware/power.h>
 
 #include <EGL/egl.h>
 #include <EGL/eglext.h>
@@ -109,6 +110,8 @@ public:
     virtual EGLNativeWindowType createWindow(int width, int height) = 0;
     virtual void destroyWindow(EGLNativeWindowType window) = 0;
     virtual void swap(EGLNativeDisplayType display, EGLSurface surface) = 0;
+    virtual bool ambientModeSupport() {return false;}
+    virtual void ambientModeEnabled(bool enable);
     virtual void sleepDisplay(bool sleep) = 0;
     virtual float refreshRate() = 0;
 
@@ -117,10 +120,12 @@ public:
     virtual bool requestUpdate(QEglFSWindow *) { return false; }
 
 protected:
-    HwComposerBackend(hw_module_t *hwc_module, void *libmsf);
+    HwComposerBackend(hw_module_t *hwc_module, power_module_t *pwr_module, void *libmsf);
     virtual ~HwComposerBackend();
 
+    bool m_ambientMode;
     hw_module_t *hwc_module;
+    power_module_t *pwr_module;
     void *libminisf;
 };
 
diff --git a/hwcomposer/hwcomposer_backend_v0.cpp b/hwcomposer/hwcomposer_backend_v0.cpp
index 0f0cd79..d37a303 100644
--- a/hwcomposer/hwcomposer_backend_v0.cpp
+++ b/hwcomposer/hwcomposer_backend_v0.cpp
@@ -44,8 +44,8 @@
 #ifdef HWC_DEVICE_API_VERSION_0_1
 #include "hwcomposer_backend_v0.h"
 
-HwComposerBackend_v0::HwComposerBackend_v0(hw_module_t *hwc_module, hw_device_t *hw_device, void *libminisf)
-    : HwComposerBackend(hwc_module, libminisf)
+HwComposerBackend_v0::HwComposerBackend_v0(hw_module_t *hwc_module, hw_device_t *hw_device, power_module_t *pwr_module, void *libminisf)
+    : HwComposerBackend(hwc_module, pwr_module, libminisf)
     , hwc_device((hwc_composer_device_t *)hw_device)
     , hwc_layer_list(NULL)
 {
diff --git a/hwcomposer/hwcomposer_backend_v0.h b/hwcomposer/hwcomposer_backend_v0.h
index 3b61657..777d7f6 100644
--- a/hwcomposer/hwcomposer_backend_v0.h
+++ b/hwcomposer/hwcomposer_backend_v0.h
@@ -47,7 +47,7 @@
 
 class HwComposerBackend_v0 : public HwComposerBackend {
 public:
-    HwComposerBackend_v0(hw_module_t *hwc_module, hw_device_t *hw_device, void *libminisf);
+    HwComposerBackend_v0(hw_module_t *hwc_module, hw_device_t *hw_device, power_module_t *pwr_module, void *libminisf);
     virtual ~HwComposerBackend_v0();
 
     virtual EGLNativeDisplayType display();
diff --git a/hwcomposer/hwcomposer_backend_v10.cpp b/hwcomposer/hwcomposer_backend_v10.cpp
index 21648fe..41e28ec 100644
--- a/hwcomposer/hwcomposer_backend_v10.cpp
+++ b/hwcomposer/hwcomposer_backend_v10.cpp
@@ -135,8 +135,8 @@ static hwc_procs_t global_procs = {
 };
 
 
-HwComposerBackend_v10::HwComposerBackend_v10(hw_module_t *hwc_module, hw_device_t *hw_device, void *libminisf)
-    : HwComposerBackend(hwc_module, libminisf)
+HwComposerBackend_v10::HwComposerBackend_v10(hw_module_t *hwc_module, hw_device_t *hw_device, power_module_t *pwr_module, void *libminisf)
+    : HwComposerBackend(hwc_module, pwr_module, libminisf)
     , hwc_device((hwc_composer_device_1_t *)hw_device)
     , hwc_list(NULL)
     , hwc_mList(NULL)
@@ -255,8 +255,16 @@ HwComposerBackend_v10::sleepDisplay(bool sleep)
     if (sleep) {
         HWC_PLUGIN_EXPECT_ZERO(hwc_device->eventControl(hwc_device, 0, HWC_EVENT_VSYNC, 0));
         HWC_PLUGIN_EXPECT_ZERO(hwc_device->blank(hwc_device, 0, 1));
+        // Enter non-interactive state after turning off the screen.
+        if (pwr_module) {
+            pwr_module->setInteractive(pwr_module, false);
+        }
     }
     else {
+        // Enter interactive state prior to turning on the screen.
+        if (pwr_module) {
+            pwr_module->setInteractive(pwr_module, true);
+        }
         HWC_PLUGIN_EXPECT_ZERO(hwc_device->blank(hwc_device, 0, 0));
         HWC_PLUGIN_EXPECT_ZERO(hwc_device->eventControl(hwc_device, 0, HWC_EVENT_VSYNC, 1));
     }
diff --git a/hwcomposer/hwcomposer_backend_v10.h b/hwcomposer/hwcomposer_backend_v10.h
index 615a958..e7a87d0 100644
--- a/hwcomposer/hwcomposer_backend_v10.h
+++ b/hwcomposer/hwcomposer_backend_v10.h
@@ -52,7 +52,7 @@
 
 class HwComposerBackend_v10 : public HwComposerBackend {
 public:
-    HwComposerBackend_v10(hw_module_t *hwc_module, hw_device_t *hw_device, void *libminisf);
+    HwComposerBackend_v10(hw_module_t *hwc_module, hw_device_t *hw_device, power_module_t *pwr_module, void *libminisf);
     virtual ~HwComposerBackend_v10();
 
     virtual EGLNativeDisplayType display();
diff --git a/hwcomposer/hwcomposer_backend_v11.cpp b/hwcomposer/hwcomposer_backend_v11.cpp
index 23e51ab..813a107 100644
--- a/hwcomposer/hwcomposer_backend_v11.cpp
+++ b/hwcomposer/hwcomposer_backend_v11.cpp
@@ -178,8 +178,8 @@ void HWComposer::present(HWComposerNativeWindowBuffer *buffer)
     }
 }
 
-HwComposerBackend_v11::HwComposerBackend_v11(hw_module_t *hwc_module, hw_device_t *hw_device, void *libminisf, int num_displays)
-    : HwComposerBackend(hwc_module, libminisf)
+HwComposerBackend_v11::HwComposerBackend_v11(hw_module_t *hwc_module, hw_device_t *hw_device, power_module_t *pwr_module, void *libminisf, int num_displays)
+    : HwComposerBackend(hwc_module, pwr_module, libminisf)
     , hwc_device((hwc_composer_device_1_t *)hw_device)
     , hwc_list(NULL)
     , hwc_mList(NULL)
@@ -359,16 +359,33 @@ HwComposerBackend_v11::sleepDisplay(bool sleep)
 
 #ifdef HWC_DEVICE_API_VERSION_1_4
         if (hwc_version == HWC_DEVICE_API_VERSION_1_4) {
-            HWC_PLUGIN_EXPECT_ZERO(hwc_device->setPowerMode(hwc_device, 0, HWC_POWER_MODE_OFF));
+            if (m_ambientMode) {
+                HWC_PLUGIN_EXPECT_ZERO(hwc_device->setPowerMode(hwc_device, 0, HWC_POWER_MODE_DOZE_SUSPEND));
+            } else {
+                HWC_PLUGIN_EXPECT_ZERO(hwc_device->setPowerMode(hwc_device, 0, HWC_POWER_MODE_OFF));
+            }
         } else
 #endif
 #ifdef HWC_DEVICE_API_VERSION_1_5
         if (hwc_version == HWC_DEVICE_API_VERSION_1_5) {
-            HWC_PLUGIN_EXPECT_ZERO(hwc_device->setPowerMode(hwc_device, 0, HWC_POWER_MODE_OFF));
+            if (m_ambientMode) {
+                HWC_PLUGIN_EXPECT_ZERO(hwc_device->setPowerMode(hwc_device, 0, HWC_POWER_MODE_DOZE_SUSPEND));
+            } else {
+                HWC_PLUGIN_EXPECT_ZERO(hwc_device->setPowerMode(hwc_device, 0, HWC_POWER_MODE_OFF));
+            }
         } else
 #endif
-            HWC_PLUGIN_EXPECT_ZERO(hwc_device->blank(hwc_device, 0, 1));
+            HWC_PLUGIN_EXPECT_ZERO(hwc_device->blank(hwc_device, 0, m_ambientMode ? 0 : 1));
+
+        // Enter non-interactive state after turning off the screen.
+        if (pwr_module) {
+            pwr_module->setInteractive(pwr_module, false);
+        }
     } else {
+        // Enter interactive state prior to turning on the screen.
+        if (pwr_module) {
+            pwr_module->setInteractive(pwr_module, true);
+        }
 #ifdef HWC_DEVICE_API_VERSION_1_4
         if (hwc_version == HWC_DEVICE_API_VERSION_1_4) {
             HWC_PLUGIN_EXPECT_ZERO(hwc_device->setPowerMode(hwc_device, 0, HWC_POWER_MODE_NORMAL));
diff --git a/hwcomposer/hwcomposer_backend_v11.h b/hwcomposer/hwcomposer_backend_v11.h
index 2c9cee0..e7c153e 100644
--- a/hwcomposer/hwcomposer_backend_v11.h
+++ b/hwcomposer/hwcomposer_backend_v11.h
@@ -58,13 +58,17 @@ class QWindow;
 
 class HwComposerBackend_v11 : public QObject, public HwComposerBackend {
 public:
-    HwComposerBackend_v11(hw_module_t *hwc_module, hw_device_t *hw_device, void *libminisf, int num_displays);
+    HwComposerBackend_v11(hw_module_t *hwc_module, hw_device_t *hw_device, power_module_t *pwr_module, void *libminisf, int num_displays);
     virtual ~HwComposerBackend_v11();
 
     virtual EGLNativeDisplayType display();
     virtual EGLNativeWindowType createWindow(int width, int height);
     virtual void destroyWindow(EGLNativeWindowType window);
     virtual void swap(EGLNativeDisplayType display, EGLSurface surface);
+    virtual bool ambientModeSupport() Q_DECL_OVERRIDE
+    {
+        return true;
+    };
     virtual void sleepDisplay(bool sleep);
     virtual float refreshRate();
     virtual bool getScreenSizes(int *width, int *height, float *physical_width, float *physical_height);
diff --git a/hwcomposer/hwcomposer_backend_v20.cpp b/hwcomposer/hwcomposer_backend_v20.cpp
index fae15ca..f8d91e8 100644
--- a/hwcomposer/hwcomposer_backend_v20.cpp
+++ b/hwcomposer/hwcomposer_backend_v20.cpp
@@ -117,22 +117,24 @@ class HWC2Window : public HWComposerNativeWindow
         hwc2_compat_display_t *hwcDisplay;
         int lastPresentFence = -1;
         bool m_syncBeforeSet;
+        HwComposerBackend_v20 *m_backend;
+        bool m_dozeWorkaround;
     protected:
         void present(HWComposerNativeWindowBuffer *buffer);
 
     public:
 
         HWC2Window(unsigned int width, unsigned int height, unsigned int format,
-                hwc2_compat_display_t *display, hwc2_compat_layer_t *layer);
+                hwc2_compat_display_t *display, hwc2_compat_layer_t *layer, HwComposerBackend_v20 *backend);
         ~HWC2Window();
         void set();
 };
 
 HWC2Window::HWC2Window(unsigned int width, unsigned int height,
                     unsigned int format, hwc2_compat_display_t* display,
-                    hwc2_compat_layer_t *layer) :
+                    hwc2_compat_layer_t *layer, HwComposerBackend_v20 *backend) :
                     HWComposerNativeWindow(width, height, format),
-                    layer(layer), hwcDisplay(display)
+                    layer(layer), hwcDisplay(display), m_backend(backend)
 {
     int bufferCount = qgetenv("QPA_HWC_BUFFER_COUNT").toInt();
     if (bufferCount)
@@ -142,6 +144,7 @@ HWC2Window::HWC2Window(unsigned int width, unsigned int height,
         bufferCount = 3;
     setBufferCount(bufferCount);
     m_syncBeforeSet = qEnvironmentVariableIsSet("QPA_HWC_SYNC_BEFORE_SET");
+    m_dozeWorkaround = qEnvironmentVariableIsSet("QPA_HWC2_FORCE_DOZE_UPDATE");
 }
 
 HWC2Window::~HWC2Window()
@@ -169,6 +172,12 @@ void HWC2Window::present(HWComposerNativeWindowBuffer *buffer)
         close(acquireFenceFd);
         acquireFenceFd = -1;
     }
+ 
+    // Some devices don't support updating the display while it's in doze mode,
+    // transition the display temporarily on to update it.
+    if (m_dozeWorkaround && m_backend->isDozing()) {
+        hwc2_compat_display_set_power_mode(hwcDisplay, HWC2_POWER_MODE_ON);
+    }
 
     error = hwc2_compat_display_validate(hwcDisplay, &numTypes,
                                                     &numRequests);
@@ -212,12 +221,16 @@ void HWC2Window::present(HWComposerNativeWindowBuffer *buffer)
     lastPresentFence = presentFence != -1 ? dup(presentFence) : -1;
 
     setFenceBufferFd(buffer, presentFence);
+
+    if (m_dozeWorkaround && m_backend->isDozing()) {
+        hwc2_compat_display_set_power_mode(hwcDisplay, HWC2_POWER_MODE_DOZE_SUSPEND);
+    }
 }
 
 int HwComposerBackend_v20::composerSequenceId = 0;
 
-HwComposerBackend_v20::HwComposerBackend_v20(hw_module_t *hwc_module, void *libminisf)
-    : HwComposerBackend(hwc_module, libminisf)
+HwComposerBackend_v20::HwComposerBackend_v20(hw_module_t *hwc_module, power_module_t *pwr_module, void *libminisf)
+    : HwComposerBackend(hwc_module, pwr_module, libminisf)
     , hwc2_device(NULL)
     , hwc2_primary_display(NULL)
     , hwc2_primary_layer(NULL)
@@ -293,7 +306,7 @@ HwComposerBackend_v20::createWindow(int width, int height)
 
     HWC2Window *hwc_win = new HWC2Window(width, height,
                                          HAL_PIXEL_FORMAT_RGBA_8888,
-                                         hwc2_primary_display, layer);
+                                         hwc2_primary_display, layer, this);
 
     return (EGLNativeWindowType) static_cast<ANativeWindow *>(hwc_win);
 }
@@ -334,8 +347,20 @@ HwComposerBackend_v20::sleepDisplay(bool sleep)
         m_vsyncTimeout.stop();
         hwc2_compat_display_set_vsync_enabled(hwc2_primary_display, HWC2_VSYNC_DISABLE);
 
-        hwc2_compat_display_set_power_mode(hwc2_primary_display, HWC2_POWER_MODE_OFF);
+        m_dozing = m_ambientMode;
+
+        int powerMode = m_ambientMode ? HWC2_POWER_MODE_DOZE_SUSPEND : HWC2_POWER_MODE_OFF;
+        hwc2_compat_display_set_power_mode(hwc2_primary_display, powerMode);
+        // Enter non-interactive state after turning off the screen.
+        if (pwr_module) {
+            pwr_module->setInteractive(pwr_module, false);
+        }
     } else {
+        m_dozing = false;
+        // Enter interactive state prior to turning on the screen.
+        if (pwr_module) {
+            pwr_module->setInteractive(pwr_module, true);
+        }
         hwc2_compat_display_set_power_mode(hwc2_primary_display, HWC2_POWER_MODE_ON);
 
         // If we have pending updates, make sure those start happening now..
diff --git a/hwcomposer/hwcomposer_backend_v20.h b/hwcomposer/hwcomposer_backend_v20.h
index f4798f4..b77c34c 100644
--- a/hwcomposer/hwcomposer_backend_v20.h
+++ b/hwcomposer/hwcomposer_backend_v20.h
@@ -58,16 +58,24 @@ class QWindow;
 
 class HwComposerBackend_v20 : public QObject, public HwComposerBackend {
 public:
-    HwComposerBackend_v20(hw_module_t *hwc_module, void *libminisf);
+    HwComposerBackend_v20(hw_module_t *hwc_module, power_module_t *pwr_module, void *libminisf);
     virtual ~HwComposerBackend_v20();
 
     virtual EGLNativeDisplayType display();
     virtual EGLNativeWindowType createWindow(int width, int height);
     virtual void destroyWindow(EGLNativeWindowType window);
     virtual void swap(EGLNativeDisplayType display, EGLSurface surface);
+    virtual bool ambientModeSupport() Q_DECL_OVERRIDE
+    {
+        return true;
+    };
     virtual void sleepDisplay(bool sleep);
     virtual float refreshRate();
     virtual bool getScreenSizes(int *width, int *height, float *physical_width, float *physical_height);
+    bool isDozing()
+    {
+        return m_dozing;
+    }
 
     virtual bool requestUpdate(QEglFSWindow *window) Q_DECL_OVERRIDE;
 
@@ -86,6 +94,7 @@ private:
     hwc2_compat_layer_t* hwc2_primary_layer;
 
     bool m_displayOff;
+    bool m_dozing;
     QBasicTimer m_deliverUpdateTimeout;
     QBasicTimer m_vsyncTimeout;
     QSet<QWindow *> m_pendingUpdate;
diff --git a/hwcomposer/hwcomposer_context.cpp b/hwcomposer/hwcomposer_context.cpp
index 95ab47f..92a0709 100644
--- a/hwcomposer/hwcomposer_context.cpp
+++ b/hwcomposer/hwcomposer_context.cpp
@@ -57,6 +57,7 @@ QT_BEGIN_NAMESPACE
 HwComposerContext::HwComposerContext()
     : info(NULL)
     , backend(NULL)
+    , ambientMode(false)
     , display_off(false)
     , window_created(false)
     , fps(0)
@@ -137,7 +138,7 @@ void HwComposerContext::destroyNativeWindow(EGLNativeWindowType window)
 
 void HwComposerContext::swapToWindow(QEglFSContext *context, QPlatformSurface *surface)
 {
-    if (display_off) {
+    if (display_off && !ambientMode) {
         qWarning("Swap requested while display is off");
         return;
     }
@@ -147,6 +148,21 @@ void HwComposerContext::swapToWindow(QEglFSContext *context, QPlatformSurface *s
     return backend->swap(egl_display, egl_surface);
 }
 
+bool HwComposerContext::ambientModeSupport()
+{
+    return backend->ambientModeSupport();
+}
+
+void HwComposerContext::ambientModeEnabled(bool enable)
+{
+    if (!ambientModeSupport()) {
+        return;
+    }
+
+    ambientMode = enable;
+    backend->ambientModeEnabled(enable);
+}
+
 void HwComposerContext::sleepDisplay(bool sleep)
 {
     if (sleep) {
diff --git a/hwcomposer/hwcomposer_context.h b/hwcomposer/hwcomposer_context.h
index 68934a4..37732de 100644
--- a/hwcomposer/hwcomposer_context.h
+++ b/hwcomposer/hwcomposer_context.h
@@ -88,6 +88,9 @@ public:
 
     void swapToWindow(QEglFSContext *context, QPlatformSurface *surface);
 
+    bool ambientModeSupport();
+    void ambientModeEnabled(bool enable);
+
     void sleepDisplay(bool sleep);
     qreal refreshRate() const;
 
@@ -96,6 +99,7 @@ public:
 private:
     HwComposerScreenInfo *info;
     HwComposerBackend *backend;
+    bool ambientMode;
     bool display_off;
     bool window_created;
     qreal fps;
diff --git a/hwcomposer/qeglfsintegration.cpp b/hwcomposer/qeglfsintegration.cpp
index e66bc84..f103700 100644
--- a/hwcomposer/qeglfsintegration.cpp
+++ b/hwcomposer/qeglfsintegration.cpp
@@ -217,6 +217,12 @@ void *QEglFSIntegration::nativeResourceForIntegration(const QByteArray &resource
 
     if (lowerCaseResource == "egldisplay") {
         return static_cast<QEglFSScreen *>(mScreen)->display();
+    } else if (lowerCaseResource == "ambientsupported") {
+        return reinterpret_cast<void *>(mHwc->ambientModeSupport());
+    } else if (lowerCaseResource == "ambientenable") {
+        mHwc->ambientModeEnabled(true);
+    } else if (lowerCaseResource == "ambientdisable") {
+        mHwc->ambientModeEnabled(false);
     } else if (lowerCaseResource == "displayoff") {
         // Called from lipstick to turn off the display (src/homeapplication.cpp)
         mHwc->sleepDisplay(true);
